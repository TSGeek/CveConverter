// <auto-generated /> using QuickType

namespace CveConverter.Models
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// cve-schema specifies the CVE JSON record format. This is the blueprint for a rich set of
    /// JSON data that can be submitted by CVE Numbering Authorities (CNAs) and Authorized Data
    /// Publishers (ADPs) to describe a CVE Record. Some examples of CVE Record data include CVE
    /// ID number, affected product(s), affected version(s), and public references. While those
    /// specific items are required when assigning a CVE, there are many other optional data in
    /// the schema that can be used to enrich CVE Records for community benefit. Learn more about
    /// the CVE program at [the official website](https://cve.mitre.org). This CVE JSON record
    /// format is defined using JSON Schema. Learn more about JSON Schema
    /// [here](https://json-schema.org/).
    /// </summary>
    public partial class JsonCve
    {
        /// <summary>
        /// A set of structures (called containers) used to store vulnerability information related
        /// to a specific CVE ID provided by a specific organization participating in the CVE
        /// program. Each container includes information provided by a different source.
        ///
        /// At a minimum, a 'cna' container containing the vulnerability information provided by the
        /// CNA who initially assigned the CVE ID must be included.
        ///
        /// There can only be one 'cna' container, as there can only be one assigning CNA. However,
        /// there can be multiple 'adp' containers, allowing multiple organizations participating in
        /// the CVE program to add additional information related to the vulnerability. For the most
        /// part, the 'cna' and 'adp' containers contain the same properties. The main differences
        /// are the source of the information. The 'cna' container requires the CNA to include
        /// certain fields, while the 'adp' container does not.
        ///
        /// A set of structures (called containers) used to store vulnerability information related
        /// to a specific CVE ID provided by a specific organization participating in the CVE
        /// program. Each container includes information provided by a different source.
        ///
        /// At minimum, a 'cna' container containing the vulnerability information provided by the
        /// CNA who initially assigned the CVE ID must be included.
        ///
        /// There can only be one 'cna' container, as there can only be one assigning CNA.
        /// </summary>
        [JsonProperty("containers")]
        public Containers Containers { get; set; }

        [JsonProperty("cveMetadata")]
        public CveMetadata CveMetadata { get; set; }

        [JsonProperty("dataType")]
        public DataType DataType { get; set; }

        [JsonProperty("dataVersion")]
        public DataVersion DataVersion { get; set; }
    }

    /// <summary>
    /// A set of structures (called containers) used to store vulnerability information related
    /// to a specific CVE ID provided by a specific organization participating in the CVE
    /// program. Each container includes information provided by a different source.
    ///
    /// At a minimum, a 'cna' container containing the vulnerability information provided by the
    /// CNA who initially assigned the CVE ID must be included.
    ///
    /// There can only be one 'cna' container, as there can only be one assigning CNA. However,
    /// there can be multiple 'adp' containers, allowing multiple organizations participating in
    /// the CVE program to add additional information related to the vulnerability. For the most
    /// part, the 'cna' and 'adp' containers contain the same properties. The main differences
    /// are the source of the information. The 'cna' container requires the CNA to include
    /// certain fields, while the 'adp' container does not.
    ///
    /// A set of structures (called containers) used to store vulnerability information related
    /// to a specific CVE ID provided by a specific organization participating in the CVE
    /// program. Each container includes information provided by a different source.
    ///
    /// At minimum, a 'cna' container containing the vulnerability information provided by the
    /// CNA who initially assigned the CVE ID must be included.
    ///
    /// There can only be one 'cna' container, as there can only be one assigning CNA.
    /// </summary>
    public partial class Containers
    {
        [JsonProperty("adp", NullValueHandling = NullValueHandling.Ignore)]
        public List<AdpContainer> Adp { get; set; }

        [JsonProperty("cna")]
        public CnaEdContainer Cna { get; set; }
    }

    /// <summary>
    /// An object containing the vulnerability information provided by an Authorized Data
    /// Publisher (ADP). Since multiple ADPs can provide information for a CVE ID, an ADP
    /// container must indicate which ADP is the source of the information in the object.
    /// </summary>
    public partial class AdpContainer
    {
        [JsonProperty("affected", NullValueHandling = NullValueHandling.Ignore)]
        public List<Product> Affected { get; set; }

        [JsonProperty("configurations", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConfigurationElement> Configurations { get; set; }

        [JsonProperty("credits", NullValueHandling = NullValueHandling.Ignore)]
        public List<Credit> Credits { get; set; }

        /// <summary>
        /// If known, the date/time the vulnerability was disclosed publicly.
        /// </summary>
        [JsonProperty("datePublic", NullValueHandling = NullValueHandling.Ignore)]
        public DateTimeOffset? DatePublic { get; set; }

        [JsonProperty("descriptions", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConfigurationElement> Descriptions { get; set; }

        [JsonProperty("exploits", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConfigurationElement> Exploits { get; set; }

        [JsonProperty("impacts", NullValueHandling = NullValueHandling.Ignore)]
        public List<Impact> Impacts { get; set; }

        [JsonProperty("metrics", NullValueHandling = NullValueHandling.Ignore)]
        public List<Metric> Metrics { get; set; }

        [JsonProperty("problemTypes", NullValueHandling = NullValueHandling.Ignore)]
        public List<ProblemType> ProblemTypes { get; set; }

        [JsonProperty("providerMetadata")]
        public ProviderMetadata ProviderMetadata { get; set; }

        [JsonProperty("references", NullValueHandling = NullValueHandling.Ignore)]
        public List<Reference> References { get; set; }

        [JsonProperty("solutions", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConfigurationElement> Solutions { get; set; }

        [JsonProperty("source", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Source { get; set; }

        [JsonProperty("tags", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(IndigoDecodeArrayConverter))]
        public List<string> Tags { get; set; }

        [JsonProperty("taxonomyMappings", NullValueHandling = NullValueHandling.Ignore)]
        public List<TaxonomyMapping> TaxonomyMappings { get; set; }

        [JsonProperty("timeline", NullValueHandling = NullValueHandling.Ignore)]
        public List<Timeline> Timeline { get; set; }

        /// <summary>
        /// A title, headline, or a brief phrase summarizing the information in an ADP container.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(AmbitiousMinMaxLengthCheckConverter))]
        public string Title { get; set; }

        [JsonProperty("workarounds", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConfigurationElement> Workarounds { get; set; }
    }

    /// <summary>
    /// List of affected products.
    ///
    /// Provides information about the set of products and services affected by this
    /// vulnerability.
    /// </summary>
    public partial class Product
    {
        /// <summary>
        /// URL identifying a package collection (determines the meaning of packageName).
        /// </summary>
        [JsonProperty("collectionURL", NullValueHandling = NullValueHandling.Ignore)]
        public String CollectionUrl { get; set; }

        /// <summary>
        /// Affected products defined by CPE. This is an array of CPE values (vulnerable and not), we
        /// use an array so that we can make multiple statements about the same version and they are
        /// separate (if we used a JSON object we'd essentially be keying on the CPE name and they
        /// would have to overlap). Also, this allows things like cveDataVersion or cveDescription to
        /// be applied directly to the product entry. This also allows more complex statements such
        /// as "Product X between versions 10.2 and 10.8" to be put in a machine-readable format. As
        /// well since multiple statements can be used multiple branches of the same product can be
        /// defined here.
        /// </summary>
        [JsonProperty("cpes", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(PurpleDecodeArrayConverter))]
        public List<string> Cpes { get; set; }

        /// <summary>
        /// The default status for versions that are not otherwise listed in the versions list. If
        /// not specified, defaultStatus defaults to 'unknown'. Versions or defaultStatus may be
        /// omitted, but not both.
        /// </summary>
        [JsonProperty("defaultStatus", NullValueHandling = NullValueHandling.Ignore)]
        public Status? DefaultStatus { get; set; }

        /// <summary>
        /// A list of the affected components, features, modules, sub-components, sub-products, APIs,
        /// commands, utilities, programs, or functionalities (optional).
        /// </summary>
        [JsonProperty("modules", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyDecodeArrayConverter))]
        public List<string> Modules { get; set; }

        /// <summary>
        /// Name or identifier of the affected software package as used in the package collection.
        /// </summary>
        [JsonProperty("packageName", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public string PackageName { get; set; }

        /// <summary>
        /// List of specific platforms if the vulnerability is only relevant in the context of these
        /// platforms (optional). Platforms may include execution environments, operating systems,
        /// virtualization technologies, hardware models, or computing architectures. The lack of
        /// this field or an empty array implies that the other fields are applicable to all relevant
        /// platforms.
        /// </summary>
        [JsonProperty("platforms", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(TentacledDecodeArrayConverter))]
        public List<string> Platforms { get; set; }

        /// <summary>
        /// Name of the affected product.
        /// </summary>
        [JsonProperty("product", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public string ProductProduct { get; set; }

        /// <summary>
        /// A list of the affected source code files (optional).
        /// </summary>
        [JsonProperty("programFiles", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(StickyDecodeArrayConverter))]
        public List<string> ProgramFiles { get; set; }

        /// <summary>
        /// A list of the affected source code functions, methods, subroutines, or procedures
        /// (optional).
        /// </summary>
        [JsonProperty("programRoutines", NullValueHandling = NullValueHandling.Ignore)]
        public List<ProgramRoutine> ProgramRoutines { get; set; }

        /// <summary>
        /// The URL of the source code repository, for informational purposes and/or to resolve git
        /// hash version ranges.
        /// </summary>
        [JsonProperty("repo", NullValueHandling = NullValueHandling.Ignore)]
        public String Repo { get; set; }

        /// <summary>
        /// Name of the organization, project, community, individual, or user that created or
        /// maintains this product or hosted service. Can be 'N/A' if none of those apply. When
        /// collectionURL and packageName are used, this field may optionally represent the user or
        /// account within the package collection associated with the package.
        /// </summary>
        [JsonProperty("vendor", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(IndecentMinMaxLengthCheckConverter))]
        public string Vendor { get; set; }

        /// <summary>
        /// Set of product versions or version ranges related to the vulnerability. The versions
        /// satisfy the CNA Rules [8.1.2
        /// requirement](https://cve.mitre.org/cve/cna/rules.html#section_8-1_cve_entry_information_requirements).
        /// Versions or defaultStatus may be omitted, but not both.
        /// </summary>
        [JsonProperty("versions", NullValueHandling = NullValueHandling.Ignore)]
        public List<VersionElement> Versions { get; set; }
    }

    /// <summary>
    /// An object describing program routine.
    /// </summary>
    public partial class ProgramRoutine
    {
        /// <summary>
        /// Name of the affected source code file, function, method, subroutine, or procedure.
        /// </summary>
        [JsonProperty("name")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public string Name { get; set; }
    }

    /// <summary>
    /// A single version or a range of versions, with vulnerability status.
    ///
    /// An entry with only 'version' and 'status' indicates the status of a single version.
    ///
    /// Otherwise, an entry describes a range; it must include the 'versionType' property, to
    /// define the version numbering semantics in use, and 'limit', to indicate the non-inclusive
    /// upper limit of the range. The object describes the status for versions V such that
    /// 'version' <= V and V < 'limit', using the <= and < semantics defined for the specific
    /// kind of 'versionType'. Status changes within the range can be specified by an optional
    /// 'changes' list.
    ///
    /// The algorithm to decide the status specified for a version V is:
    ///
    /// for entry in product.versions {
    /// if entry.lessThan is not present and entry.lessThanOrEqual is not present and v ==
    /// entry.version {
    /// return entry.status
    /// }
    /// if (entry.lessThan is present and entry.version <= v and v < entry.lessThan)
    /// or
    /// (entry.lessThanOrEqual is present and entry.version <= v and v <= entry.lessThanOrEqual)
    /// { // <= and < defined by entry.versionType
    /// status = entry.status
    /// for change in entry.changes {
    /// if change.at <= v {
    /// status = change.status
    /// }
    /// }
    /// return status
    /// }
    /// }
    /// return product.defaultStatus
    ///
    /// .
    /// </summary>
    public partial class VersionElement
    {
        /// <summary>
        /// A list of status changes that take place during the range. The array should be sorted in
        /// increasing order by the 'at' field, according to the versionType, but clients must
        /// re-sort the list themselves rather than assume it is sorted.
        /// </summary>
        [JsonProperty("changes", NullValueHandling = NullValueHandling.Ignore)]
        public List<Change> Changes { get; set; }

        /// <summary>
        /// The non-inclusive upper limit of the range. This is the least version NOT in the range.
        /// The usual version syntax is expanded to allow a pattern to end in an asterisk `(*)`,
        /// indicating an arbitrarily large number in the version ordering. For example, `{version:
        /// 1.0 lessThan: 1.*}` would describe the entire 1.X branch for most range kinds, and
        /// `{version: 2.0, lessThan: *}` describes all versions starting at 2.0, including 3.0, 5.1,
        /// and so on. Only one of lessThan and lessThanOrEqual should be specified.
        /// </summary>
        [JsonProperty("lessThan", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(IndigoMinMaxLengthCheckConverter))]
        public string LessThan { get; set; }

        /// <summary>
        /// The inclusive upper limit of the range. This is the greatest version contained in the
        /// range. Only one of lessThan and lessThanOrEqual should be specified. For example,
        /// `{version: 1.0, lessThanOrEqual: 1.3}` covers all versions from 1.0 up to and including
        /// 1.3.
        /// </summary>
        [JsonProperty("lessThanOrEqual", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(IndigoMinMaxLengthCheckConverter))]
        public string LessThanOrEqual { get; set; }

        /// <summary>
        /// The vulnerability status for the version or range of versions. For a range, the status
        /// may be refined by the 'changes' list.
        /// </summary>
        [JsonProperty("status")]
        public Status Status { get; set; }

        /// <summary>
        /// The single version being described, or the version at the start of the range. By
        /// convention, typically 0 denotes the earliest possible version.
        /// </summary>
        [JsonProperty("version")]
        [JsonConverter(typeof(IndigoMinMaxLengthCheckConverter))]
        public string Version { get; set; }

        /// <summary>
        /// The version numbering system used for specifying the range. This defines the exact
        /// semantics of the comparison (less-than) operation on versions, which is required to
        /// understand the range itself. 'Custom' indicates that the version type is unspecified and
        /// should be avoided whenever possible. It is included primarily for use in conversion of
        /// older data files.
        /// </summary>
        [JsonProperty("versionType", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(HilariousMinMaxLengthCheckConverter))]
        public string VersionType { get; set; }
    }

    /// <summary>
    /// The start of a single status change during the range.
    /// </summary>
    public partial class Change
    {
        /// <summary>
        /// The version at which a status change occurs.
        /// </summary>
        [JsonProperty("at")]
        [JsonConverter(typeof(IndigoMinMaxLengthCheckConverter))]
        public string At { get; set; }

        /// <summary>
        /// The new status in the range starting at the given version.
        /// </summary>
        [JsonProperty("status")]
        public Status Status { get; set; }
    }

    /// <summary>
    /// Configurations required for exploiting this vulnerability.
    ///
    /// Text in a particular language with optional alternate markup or formatted representation
    /// (e.g., Markdown) or embedded media.
    ///
    /// A list of multi-lingual descriptions of the vulnerability. E.g., [PROBLEMTYPE] in
    /// [COMPONENT] in [VENDOR] [PRODUCT] [VERSION] on [PLATFORMS] allows [ATTACKER] to [IMPACT]
    /// via [VECTOR]. OR [COMPONENT] in [VENDOR] [PRODUCT] [VERSION] [ROOT CAUSE], which allows
    /// [ATTACKER] to [IMPACT] via [VECTOR].
    ///
    /// Information about exploits of the vulnerability.
    ///
    /// Information about solutions or remediations available for this vulnerability.
    ///
    /// Workarounds and mitigations for this vulnerability.
    /// </summary>
    public partial class ConfigurationElement
    {
        [JsonProperty("lang")]
        public string Lang { get; set; }

        /// <summary>
        /// Supporting media data for the description such as markdown, diagrams, .. (optional).
        /// Similar to RFC 2397 each media object has three main parts: media type, media data value,
        /// and an optional boolean flag to indicate if the media data is base64 encoded.
        /// </summary>
        [JsonProperty("supportingMedia", NullValueHandling = NullValueHandling.Ignore)]
        public List<SupportingMedia> SupportingMedia { get; set; }

        /// <summary>
        /// Plain text description.
        /// </summary>
        [JsonProperty("value")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public string Value { get; set; }
    }

    public partial class SupportingMedia
    {
        /// <summary>
        /// If true then the value field contains the media data encoded in base64. If false then the
        /// value field contains the UTF-8 media content.
        /// </summary>
        [JsonProperty("base64", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Base64 { get; set; }

        /// <summary>
        /// RFC2046 compliant IANA Media type for eg., text/markdown, text/html.
        /// </summary>
        [JsonProperty("type")]
        [JsonConverter(typeof(AmbitiousMinMaxLengthCheckConverter))]
        public string Type { get; set; }

        /// <summary>
        /// Supporting media content, up to 16K. If base64 is true, this field stores base64 encoded
        /// data.
        /// </summary>
        [JsonProperty("value")]
        [JsonConverter(typeof(CunningMinMaxLengthCheckConverter))]
        public string Value { get; set; }
    }

    /// <summary>
    /// Statements acknowledging specific people, organizations, or tools recognizing the work
    /// done in researching, discovering, remediating or helping with activities related to this
    /// CVE.
    /// </summary>
    public partial class Credit
    {
        /// <summary>
        /// The language used when describing the credits. The language field is included so that CVE
        /// Records can support translations. The value must be a BCP 47 language code.
        /// </summary>
        [JsonProperty("lang")]
        public string Lang { get; set; }

        /// <summary>
        /// Type or role of the entity being credited (optional). finder: identifies the
        /// vulnerability.
        /// reporter: notifies the vendor of the vulnerability to a CNA.
        /// analyst: validates the vulnerability to ensure accuracy or severity.
        /// coordinator: facilitates the coordinated response process.
        /// remediation developer: prepares a code change or other remediation plans.
        /// remediation reviewer: reviews vulnerability remediation plans or code changes for
        /// effectiveness and completeness.
        /// remediation verifier: tests and verifies the vulnerability or its remediation.
        /// tool: names of tools used in vulnerability discovery or identification.
        /// sponsor: supports the vulnerability identification or remediation activities.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public TypeEnum? Type { get; set; }

        /// <summary>
        /// UUID of the user being credited if present in the CVE User Registry (optional). This UUID
        /// can be used to lookup the user record in the user registry service.
        /// </summary>
        [JsonProperty("user", NullValueHandling = NullValueHandling.Ignore)]
        public string User { get; set; }

        [JsonProperty("value")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public string Value { get; set; }
    }

    /// <summary>
    /// Collection of impacts of this vulnerability.
    ///
    /// This is impact type information (e.g. a text description.
    /// </summary>
    public partial class Impact
    {
        /// <summary>
        /// CAPEC ID that best relates to this impact.
        /// </summary>
        [JsonProperty("capecId", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MagentaMinMaxLengthCheckConverter))]
        public string CapecId { get; set; }

        /// <summary>
        /// Prose description of the impact scenario. At a minimum provide the description given by
        /// CAPEC.
        /// </summary>
        [JsonProperty("descriptions")]
        public List<ConfigurationElement> Descriptions { get; set; }
    }

    /// <summary>
    /// Collection of impact scores with attribution.
    ///
    /// This is impact type information (e.g. a text description, CVSSv2, CVSSv3, etc.). Must
    /// contain: At least one entry, can be text, CVSSv2, CVSSv3, others may be added.
    /// </summary>
    public partial class Metric
    {
        [JsonProperty("cvssV2_0", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForCommonVulnerabilityScoringSystemVersion20 CvssV20 { get; set; }

        [JsonProperty("cvssV3_0", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForCommonVulnerabilityScoringSystemVersion30 CvssV30 { get; set; }

        [JsonProperty("cvssV3_1", NullValueHandling = NullValueHandling.Ignore)]
        public JsonSchemaForCommonVulnerabilityScoringSystemVersion31 CvssV31 { get; set; }

        /// <summary>
        /// Name of the scoring format. This provides a bit of future proofing. Additional properties
        /// are not prohibited, so this will support the inclusion of proprietary formats. It also
        /// provides an easy future conversion mechanism when future score formats become part of the
        /// schema. example: cvssV44, format = 'cvssV44', other = cvssV4_4 JSON object. In the
        /// future, the other properties can be converted to score properties when they become part
        /// of the schema.
        /// </summary>
        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FriskyMinMaxLengthCheckConverter))]
        public string Format { get; set; }

        /// <summary>
        /// A non-standard impact description, may be prose or JSON block.
        /// </summary>
        [JsonProperty("other", NullValueHandling = NullValueHandling.Ignore)]
        public Other Other { get; set; }

        /// <summary>
        /// Description of the scenarios this metrics object applies to. If no specific scenario is
        /// given, GENERAL is used as the default and applies when no more specific metric matches.
        /// </summary>
        [JsonProperty("scenarios", NullValueHandling = NullValueHandling.Ignore)]
        public List<Scenario> Scenarios { get; set; }
    }

    public partial class JsonSchemaForCommonVulnerabilityScoringSystemVersion20
    {
        [JsonProperty("accessComplexity", NullValueHandling = NullValueHandling.Ignore)]
        public AccessComplexityType? AccessComplexity { get; set; }

        [JsonProperty("accessVector", NullValueHandling = NullValueHandling.Ignore)]
        public AccessVectorType? AccessVector { get; set; }

        [JsonProperty("authentication", NullValueHandling = NullValueHandling.Ignore)]
        public AuthenticationType? Authentication { get; set; }

        [JsonProperty("availabilityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public CiaType? AvailabilityImpact { get; set; }

        [JsonProperty("availabilityRequirement", NullValueHandling = NullValueHandling.Ignore)]
        public CiaRequirementType? AvailabilityRequirement { get; set; }

        [JsonProperty("baseScore")]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double BaseScore { get; set; }

        [JsonProperty("collateralDamagePotential", NullValueHandling = NullValueHandling.Ignore)]
        public CollateralDamagePotentialType? CollateralDamagePotential { get; set; }

        [JsonProperty("confidentialityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public CiaType? ConfidentialityImpact { get; set; }

        [JsonProperty("confidentialityRequirement", NullValueHandling = NullValueHandling.Ignore)]
        public CiaRequirementType? ConfidentialityRequirement { get; set; }

        [JsonProperty("environmentalScore", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double? EnvironmentalScore { get; set; }

        [JsonProperty("exploitability", NullValueHandling = NullValueHandling.Ignore)]
        public ExploitityType? Exploitability { get; set; }

        [JsonProperty("integrityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public CiaType? IntegrityImpact { get; set; }

        [JsonProperty("integrityRequirement", NullValueHandling = NullValueHandling.Ignore)]
        public CiaRequirementType? IntegrityRequirement { get; set; }

        [JsonProperty("remediationLevel", NullValueHandling = NullValueHandling.Ignore)]
        public RemediationLevelType? RemediationLevel { get; set; }

        [JsonProperty("reportConfidence", NullValueHandling = NullValueHandling.Ignore)]
        public ReportConfidenceType? ReportConfidence { get; set; }

        [JsonProperty("targetDistribution", NullValueHandling = NullValueHandling.Ignore)]
        public TargetDistributionType? TargetDistribution { get; set; }

        [JsonProperty("temporalScore", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double? TemporalScore { get; set; }

        [JsonProperty("vectorString")]
        public string VectorString { get; set; }

        /// <summary>
        /// CVSS Version
        /// </summary>
        [JsonProperty("version")]
        public CvssV20_Version Version { get; set; }
    }

    public partial class JsonSchemaForCommonVulnerabilityScoringSystemVersion30
    {
        [JsonProperty("attackComplexity", NullValueHandling = NullValueHandling.Ignore)]
        public AttackComplexityType? AttackComplexity { get; set; }

        [JsonProperty("attackVector", NullValueHandling = NullValueHandling.Ignore)]
        public AttackVectorType? AttackVector { get; set; }

        [JsonProperty("availabilityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public AvailabilityImpactEnum? AvailabilityImpact { get; set; }

        [JsonProperty("availabilityRequirement", NullValueHandling = NullValueHandling.Ignore)]
        public CiaRequirementType? AvailabilityRequirement { get; set; }

        [JsonProperty("baseScore")]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double BaseScore { get; set; }

        [JsonProperty("baseSeverity")]
        public SeverityType BaseSeverity { get; set; }

        [JsonProperty("confidentialityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public AvailabilityImpactEnum? ConfidentialityImpact { get; set; }

        [JsonProperty("confidentialityRequirement", NullValueHandling = NullValueHandling.Ignore)]
        public CiaRequirementType? ConfidentialityRequirement { get; set; }

        [JsonProperty("environmentalScore", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double? EnvironmentalScore { get; set; }

        [JsonProperty("environmentalSeverity", NullValueHandling = NullValueHandling.Ignore)]
        public SeverityType? EnvironmentalSeverity { get; set; }

        [JsonProperty("exploitCodeMaturity", NullValueHandling = NullValueHandling.Ignore)]
        public ExploitityType? ExploitCodeMaturity { get; set; }

        [JsonProperty("integrityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public AvailabilityImpactEnum? IntegrityImpact { get; set; }

        [JsonProperty("integrityRequirement", NullValueHandling = NullValueHandling.Ignore)]
        public CiaRequirementType? IntegrityRequirement { get; set; }

        [JsonProperty("modifiedAttackComplexity", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedAttackComplexityType? ModifiedAttackComplexity { get; set; }

        [JsonProperty("modifiedAttackVector", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedAttackVectorType? ModifiedAttackVector { get; set; }

        [JsonProperty("modifiedAvailabilityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedType? ModifiedAvailabilityImpact { get; set; }

        [JsonProperty("modifiedConfidentialityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedType? ModifiedConfidentialityImpact { get; set; }

        [JsonProperty("modifiedIntegrityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedType? ModifiedIntegrityImpact { get; set; }

        [JsonProperty("modifiedPrivilegesRequired", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedType? ModifiedPrivilegesRequired { get; set; }

        [JsonProperty("modifiedScope", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedScopeType? ModifiedScope { get; set; }

        [JsonProperty("modifiedUserInteraction", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedUserInteractionType? ModifiedUserInteraction { get; set; }

        [JsonProperty("privilegesRequired", NullValueHandling = NullValueHandling.Ignore)]
        public AvailabilityImpactEnum? PrivilegesRequired { get; set; }

        [JsonProperty("remediationLevel", NullValueHandling = NullValueHandling.Ignore)]
        public RemediationLevelType? RemediationLevel { get; set; }

        [JsonProperty("reportConfidence", NullValueHandling = NullValueHandling.Ignore)]
        public ConfidenceType? ReportConfidence { get; set; }

        [JsonProperty("scope", NullValueHandling = NullValueHandling.Ignore)]
        public ScopeType? Scope { get; set; }

        [JsonProperty("temporalScore", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double? TemporalScore { get; set; }

        [JsonProperty("temporalSeverity", NullValueHandling = NullValueHandling.Ignore)]
        public SeverityType? TemporalSeverity { get; set; }

        [JsonProperty("userInteraction", NullValueHandling = NullValueHandling.Ignore)]
        public UserInteractionType? UserInteraction { get; set; }

        [JsonProperty("vectorString")]
        public string VectorString { get; set; }

        /// <summary>
        /// CVSS Version
        /// </summary>
        [JsonProperty("version")]
        public CvssV30_Version Version { get; set; }
    }

    public partial class JsonSchemaForCommonVulnerabilityScoringSystemVersion31
    {
        [JsonProperty("attackComplexity", NullValueHandling = NullValueHandling.Ignore)]
        public AttackComplexityType? AttackComplexity { get; set; }

        [JsonProperty("attackVector", NullValueHandling = NullValueHandling.Ignore)]
        public AttackVectorType? AttackVector { get; set; }

        [JsonProperty("availabilityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public AvailabilityImpactEnum? AvailabilityImpact { get; set; }

        [JsonProperty("availabilityRequirement", NullValueHandling = NullValueHandling.Ignore)]
        public CiaRequirementType? AvailabilityRequirement { get; set; }

        [JsonProperty("baseScore")]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double BaseScore { get; set; }

        [JsonProperty("baseSeverity")]
        public SeverityType BaseSeverity { get; set; }

        [JsonProperty("confidentialityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public AvailabilityImpactEnum? ConfidentialityImpact { get; set; }

        [JsonProperty("confidentialityRequirement", NullValueHandling = NullValueHandling.Ignore)]
        public CiaRequirementType? ConfidentialityRequirement { get; set; }

        [JsonProperty("environmentalScore", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double? EnvironmentalScore { get; set; }

        [JsonProperty("environmentalSeverity", NullValueHandling = NullValueHandling.Ignore)]
        public SeverityType? EnvironmentalSeverity { get; set; }

        [JsonProperty("exploitCodeMaturity", NullValueHandling = NullValueHandling.Ignore)]
        public ExploitityType? ExploitCodeMaturity { get; set; }

        [JsonProperty("integrityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public AvailabilityImpactEnum? IntegrityImpact { get; set; }

        [JsonProperty("integrityRequirement", NullValueHandling = NullValueHandling.Ignore)]
        public CiaRequirementType? IntegrityRequirement { get; set; }

        [JsonProperty("modifiedAttackComplexity", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedAttackComplexityType? ModifiedAttackComplexity { get; set; }

        [JsonProperty("modifiedAttackVector", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedAttackVectorType? ModifiedAttackVector { get; set; }

        [JsonProperty("modifiedAvailabilityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedType? ModifiedAvailabilityImpact { get; set; }

        [JsonProperty("modifiedConfidentialityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedType? ModifiedConfidentialityImpact { get; set; }

        [JsonProperty("modifiedIntegrityImpact", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedType? ModifiedIntegrityImpact { get; set; }

        [JsonProperty("modifiedPrivilegesRequired", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedType? ModifiedPrivilegesRequired { get; set; }

        [JsonProperty("modifiedScope", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedScopeType? ModifiedScope { get; set; }

        [JsonProperty("modifiedUserInteraction", NullValueHandling = NullValueHandling.Ignore)]
        public ModifiedUserInteractionType? ModifiedUserInteraction { get; set; }

        [JsonProperty("privilegesRequired", NullValueHandling = NullValueHandling.Ignore)]
        public AvailabilityImpactEnum? PrivilegesRequired { get; set; }

        [JsonProperty("remediationLevel", NullValueHandling = NullValueHandling.Ignore)]
        public RemediationLevelType? RemediationLevel { get; set; }

        [JsonProperty("reportConfidence", NullValueHandling = NullValueHandling.Ignore)]
        public ConfidenceType? ReportConfidence { get; set; }

        [JsonProperty("scope", NullValueHandling = NullValueHandling.Ignore)]
        public ScopeType? Scope { get; set; }

        [JsonProperty("temporalScore", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double? TemporalScore { get; set; }

        [JsonProperty("temporalSeverity", NullValueHandling = NullValueHandling.Ignore)]
        public SeverityType? TemporalSeverity { get; set; }

        [JsonProperty("userInteraction", NullValueHandling = NullValueHandling.Ignore)]
        public UserInteractionType? UserInteraction { get; set; }

        [JsonProperty("vectorString")]
        public string VectorString { get; set; }

        /// <summary>
        /// CVSS Version
        /// </summary>
        [JsonProperty("version")]
        public CvssV31_Version Version { get; set; }
    }

    /// <summary>
    /// A non-standard impact description, may be prose or JSON block.
    /// </summary>
    public partial class Other
    {
        /// <summary>
        /// JSON object not covered by another metrics format.
        /// </summary>
        [JsonProperty("content")]
        public Dictionary<string, object> Content { get; set; }

        /// <summary>
        /// Name of the non-standard impact metrics format used.
        /// </summary>
        [JsonProperty("type")]
        [JsonConverter(typeof(HilariousMinMaxLengthCheckConverter))]
        public string Type { get; set; }
    }

    public partial class Scenario
    {
        [JsonProperty("lang")]
        public string Lang { get; set; }

        /// <summary>
        /// Description of the scenario this metrics object applies to. If no specific scenario is
        /// given, GENERAL is used as the default and applies when no more specific metric matches.
        /// </summary>
        [JsonProperty("value")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public string Value { get; set; }
    }

    /// <summary>
    /// This is problem type information (e.g. CWE identifier). Must contain: At least one entry,
    /// can be text, OWASP, CWE, please note that while only one is required you can use more
    /// than one (or indeed all three) as long as they are correct). (CNA requirement:
    /// [PROBLEMTYPE]).
    /// </summary>
    public partial class ProblemType
    {
        [JsonProperty("descriptions")]
        public List<ProblemTypeDescription> Descriptions { get; set; }
    }

    public partial class ProblemTypeDescription
    {
        /// <summary>
        /// CWE ID of the CWE that best describes this problemType entry.
        /// </summary>
        [JsonProperty("cweId", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MischievousMinMaxLengthCheckConverter))]
        public string CweId { get; set; }

        /// <summary>
        /// Text description of problemType, or title from CWE or OWASP.
        /// </summary>
        [JsonProperty("description")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public string Description { get; set; }

        [JsonProperty("lang")]
        public string Lang { get; set; }

        [JsonProperty("references", NullValueHandling = NullValueHandling.Ignore)]
        public List<Reference> References { get; set; }

        /// <summary>
        /// Problemtype source, text, OWASP, CWE, etc.,
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(HilariousMinMaxLengthCheckConverter))]
        public string Type { get; set; }
    }

    /// <summary>
    /// This is reference data in the form of URLs or file objects (uuencoded and embedded within
    /// the JSON file, exact format to be decided, e.g. we may require a compressed format so the
    /// objects require unpacking before they are "dangerous").
    /// </summary>
    public partial class Reference
    {
        /// <summary>
        /// User created name for the reference, often the title of the page.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(IndecentMinMaxLengthCheckConverter))]
        public string Name { get; set; }

        /// <summary>
        /// An array of one or more tags that describe the resource referenced by 'url'.
        /// </summary>
        [JsonProperty("tags", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(IndigoDecodeArrayConverter))]
        public List<string> Tags { get; set; }

        /// <summary>
        /// The uniform resource locator (URL), according to [RFC
        /// 3986](https://tools.ietf.org/html/rfc3986#section-1.1.3), that can be used to retrieve
        /// the referenced resource.
        /// </summary>
        [JsonProperty("url")]
        public String Url { get; set; }
    }

    /// <summary>
    /// Details related to the information container provider (CNA or ADP).
    /// </summary>
    public partial class ProviderMetadata
    {
        /// <summary>
        /// Timestamp to be set by the system of record at time of submission. If dateUpdated is
        /// provided to the system of record it will be replaced by the current timestamp at the time
        /// of submission.
        /// </summary>
        [JsonProperty("dateUpdated", NullValueHandling = NullValueHandling.Ignore)]
        public DateTimeOffset? DateUpdated { get; set; }

        /// <summary>
        /// The container provider's organizational UUID.
        /// </summary>
        [JsonProperty("orgId")]
        public string OrgId { get; set; }

        /// <summary>
        /// The container provider's organizational short name.
        /// </summary>
        [JsonProperty("shortName", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxLengthCheckConverter1))]
        public string ShortName { get; set; }
    }

    /// <summary>
    /// List of taxonomy items related to the vulnerability.
    /// </summary>
    public partial class TaxonomyMapping
    {
        /// <summary>
        /// The name of the taxonomy.
        /// </summary>
        [JsonProperty("taxonomyName")]
        [JsonConverter(typeof(HilariousMinMaxLengthCheckConverter))]
        public string TaxonomyName { get; set; }

        [JsonProperty("taxonomyRelations")]
        public List<TaxonomyRelation> TaxonomyRelations { get; set; }

        /// <summary>
        /// The version of taxonomy the identifiers come from.
        /// </summary>
        [JsonProperty("taxonomyVersion", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(HilariousMinMaxLengthCheckConverter))]
        public string TaxonomyVersion { get; set; }
    }

    /// <summary>
    /// List of relationships to the taxonomy for the vulnerability.  Relationships can be
    /// between the taxonomy and the CVE or two taxonomy items.
    /// </summary>
    public partial class TaxonomyRelation
    {
        /// <summary>
        /// A description of the relationship.
        /// </summary>
        [JsonProperty("relationshipName")]
        [JsonConverter(typeof(HilariousMinMaxLengthCheckConverter))]
        public string RelationshipName { get; set; }

        /// <summary>
        /// The target of the relationship.  Can be the CVE ID or another taxonomy identifier.
        /// </summary>
        [JsonProperty("relationshipValue")]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public string RelationshipValue { get; set; }

        /// <summary>
        /// Identifier of the item in the taxonomy.  Used as the subject of the relationship.
        /// </summary>
        [JsonProperty("taxonomyId")]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public string TaxonomyId { get; set; }
    }

    /// <summary>
    /// This is timeline information for significant events about this vulnerability or changes
    /// to the CVE Record.
    /// </summary>
    public partial class Timeline
    {
        /// <summary>
        /// The language used in the description of the event. The language field is included so that
        /// CVE Records can support translations. The value must be a BCP 47 language code.
        /// </summary>
        [JsonProperty("lang")]
        public string Lang { get; set; }

        /// <summary>
        /// Timestamp representing when the event in the timeline occurred. The timestamp format is
        /// based on RFC3339 and ISO ISO8601, with an optional timezone. yyyy-MM-ddTHH:mm:ssZZZZ - if
        /// the timezone offset is not given, GMT (0000) is assumed.
        /// </summary>
        [JsonProperty("time")]
        public DateTimeOffset Time { get; set; }

        /// <summary>
        /// A summary of the event.
        /// </summary>
        [JsonProperty("value")]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public string Value { get; set; }
    }

    /// <summary>
    /// An object containing the vulnerability information provided by a CVE Numbering Authority
    /// (CNA) for a published CVE ID. There can only be one CNA container per CVE record since
    /// there can only be one assigning CNA. The CNA container must include the required
    /// information defined in the CVE Rules, which includes a product, version, problem type,
    /// prose description, and a reference.
    ///
    /// An object containing the vulnerability information provided by a CVE Numbering Authority
    /// (CNA) for a rejected CVE ID. There can only be one CNA container per CVE record since
    /// there can only be one assigning CNA.
    /// </summary>
    public partial class CnaEdContainer
    {
        [JsonProperty("affected", NullValueHandling = NullValueHandling.Ignore)]
        public List<Product> Affected { get; set; }

        [JsonProperty("configurations", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConfigurationElement> Configurations { get; set; }

        [JsonProperty("credits", NullValueHandling = NullValueHandling.Ignore)]
        public List<Credit> Credits { get; set; }

        /// <summary>
        /// The date/time this CVE ID was associated with a vulnerability by a CNA.
        /// </summary>
        [JsonProperty("dateAssigned", NullValueHandling = NullValueHandling.Ignore)]
        public DateTimeOffset? DateAssigned { get; set; }

        /// <summary>
        /// If known, the date/time the vulnerability was disclosed publicly.
        /// </summary>
        [JsonProperty("datePublic", NullValueHandling = NullValueHandling.Ignore)]
        public DateTimeOffset? DatePublic { get; set; }

        [JsonProperty("descriptions", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConfigurationElement> Descriptions { get; set; }

        [JsonProperty("exploits", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConfigurationElement> Exploits { get; set; }

        [JsonProperty("impacts", NullValueHandling = NullValueHandling.Ignore)]
        public List<Impact> Impacts { get; set; }

        [JsonProperty("metrics", NullValueHandling = NullValueHandling.Ignore)]
        public List<Metric> Metrics { get; set; }

        [JsonProperty("problemTypes", NullValueHandling = NullValueHandling.Ignore)]
        public List<ProblemType> ProblemTypes { get; set; }

        [JsonProperty("providerMetadata")]
        public ProviderMetadata ProviderMetadata { get; set; }

        [JsonProperty("references", NullValueHandling = NullValueHandling.Ignore)]
        public List<Reference> References { get; set; }

        [JsonProperty("solutions", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConfigurationElement> Solutions { get; set; }

        [JsonProperty("source", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Source { get; set; }

        [JsonProperty("tags", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(IndigoDecodeArrayConverter))]
        public List<string> Tags { get; set; }

        [JsonProperty("taxonomyMappings", NullValueHandling = NullValueHandling.Ignore)]
        public List<TaxonomyMapping> TaxonomyMappings { get; set; }

        [JsonProperty("timeline", NullValueHandling = NullValueHandling.Ignore)]
        public List<Timeline> Timeline { get; set; }

        /// <summary>
        /// A title, headline, or a brief phrase summarizing the CVE record. Eg., Buffer overflow in
        /// Example Soft.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(AmbitiousMinMaxLengthCheckConverter))]
        public string Title { get; set; }

        [JsonProperty("workarounds", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConfigurationElement> Workarounds { get; set; }

        /// <summary>
        /// Reasons for rejecting this CVE Record.
        /// </summary>
        [JsonProperty("rejectedReasons", NullValueHandling = NullValueHandling.Ignore)]
        public List<ConfigurationElement> RejectedReasons { get; set; }

        /// <summary>
        /// Contains an array of CVE IDs that this CVE ID was rejected in favor of because this CVE
        /// ID was assigned to the vulnerabilities.
        /// </summary>
        [JsonProperty("replacedBy", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> ReplacedBy { get; set; }
    }

    /// <summary>
    /// This is meta data about the CVE ID such as the CVE ID, who requested it, who assigned it,
    /// when it was requested, the current state (PUBLISHED, REJECTED, etc.) and so on.  These
    /// fields are controlled by the CVE Services.
    /// </summary>
    public partial class CveMetadata
    {
        /// <summary>
        /// The UUID for the organization to which the CVE ID was originally assigned. This UUID can
        /// be used to lookup the organization record in the user registry service.
        ///
        /// The UUID for the organization to which the CVE ID was originally assigned.
        /// </summary>
        [JsonProperty("assignerOrgId")]
        public string AssignerOrgId { get; set; }

        /// <summary>
        /// The short name for the organization to which the CVE ID was originally assigned.
        /// </summary>
        [JsonProperty("assignerShortName", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxLengthCheckConverter1))]
        public string AssignerShortName { get; set; }

        /// <summary>
        /// The CVE identifier that this record pertains to.
        /// </summary>
        [JsonProperty("cveId")]
        public string CveId { get; set; }

        /// <summary>
        /// The date/time the CVE Record was first published in the CVE List.
        /// </summary>
        [JsonProperty("datePublished", NullValueHandling = NullValueHandling.Ignore)]
        public DateTimeOffset? DatePublished { get; set; }

        /// <summary>
        /// The date/time this CVE ID was reserved in the CVE automation workgroup services system.
        /// Disclaimer: This date reflects when the CVE ID was reserved, and does not necessarily
        /// indicate when this vulnerability was discovered, shared with the affected vendor,
        /// publicly disclosed, or updated in CVE.
        /// </summary>
        [JsonProperty("dateReserved", NullValueHandling = NullValueHandling.Ignore)]
        public DateTimeOffset? DateReserved { get; set; }

        /// <summary>
        /// The date/time the record was last updated.
        /// </summary>
        [JsonProperty("dateUpdated", NullValueHandling = NullValueHandling.Ignore)]
        public DateTimeOffset? DateUpdated { get; set; }

        /// <summary>
        /// The user that requested the CVE identifier.
        /// </summary>
        [JsonProperty("requesterUserId", NullValueHandling = NullValueHandling.Ignore)]
        public string RequesterUserId { get; set; }

        /// <summary>
        /// The system of record causes this to start at 1, and increment by 1 each time a submission
        /// from a data provider changes this CVE Record. The incremented value moves to the Rejected
        /// schema upon a PUBLISHED->REJECTED transition, and moves to the Published schema upon a
        /// REJECTED->PUBLISHED transition.
        /// </summary>
        [JsonProperty("serial", NullValueHandling = NullValueHandling.Ignore)]
        public long? Serial { get; set; }

        /// <summary>
        /// State of CVE - PUBLISHED, REJECTED.
        /// </summary>
        [JsonProperty("state")]
        public State State { get; set; }

        /// <summary>
        /// The date/time the CVE ID was rejected.
        /// </summary>
        [JsonProperty("dateRejected", NullValueHandling = NullValueHandling.Ignore)]
        public DateTimeOffset? DateRejected { get; set; }
    }

    /// <summary>
    /// The default status for versions that are not otherwise listed in the versions list. If
    /// not specified, defaultStatus defaults to 'unknown'. Versions or defaultStatus may be
    /// omitted, but not both.
    ///
    /// The vulnerability status of a given version or range of versions of a product. The
    /// statuses 'affected' and 'unaffected' indicate that the version is affected or unaffected
    /// by the vulnerability. The status 'unknown' indicates that it is unknown or unspecified
    /// whether the given version is affected. There can be many reasons for an 'unknown' status,
    /// including that an investigation has not been undertaken or that a vendor has not
    /// disclosed the status.
    ///
    /// The new status in the range starting at the given version.
    ///
    /// The vulnerability status for the version or range of versions. For a range, the status
    /// may be refined by the 'changes' list.
    /// </summary>
    public enum Status { Affected, Unaffected, Unknown };

    /// <summary>
    /// Type or role of the entity being credited (optional). finder: identifies the
    /// vulnerability.
    /// reporter: notifies the vendor of the vulnerability to a CNA.
    /// analyst: validates the vulnerability to ensure accuracy or severity.
    /// coordinator: facilitates the coordinated response process.
    /// remediation developer: prepares a code change or other remediation plans.
    /// remediation reviewer: reviews vulnerability remediation plans or code changes for
    /// effectiveness and completeness.
    /// remediation verifier: tests and verifies the vulnerability or its remediation.
    /// tool: names of tools used in vulnerability discovery or identification.
    /// sponsor: supports the vulnerability identification or remediation activities.
    /// </summary>
    public enum TypeEnum { Analyst, Coordinator, Finder, Other, RemediationDeveloper, RemediationReviewer, RemediationVerifier, Reporter, Sponsor, Tool };

    public enum AccessComplexityType { High, Low, Medium };

    public enum AccessVectorType { AdjacentNetwork, Local, Network };

    public enum AuthenticationType { Multiple, None, Single };

    public enum CiaType { Complete, None, Partial };

    public enum CiaRequirementType { High, Low, Medium, NotDefined };

    public enum CollateralDamagePotentialType { High, Low, LowMedium, MediumHigh, None, NotDefined };

    public enum ExploitityType { Functional, High, NotDefined, ProofOfConcept, Unproven };

    public enum RemediationLevelType { NotDefined, OfficialFix, TemporaryFix, Unavailable, Workaround };

    public enum ReportConfidenceType { Confirmed, NotDefined, Unconfirmed, Uncorroborated };

    public enum TargetDistributionType { High, Low, Medium, None, NotDefined };

    /// <summary>
    /// CVSS Version
    /// </summary>
    public enum CvssV20_Version { The20 };

    public enum AttackComplexityType { High, Low };

    public enum AttackVectorType { AdjacentNetwork, Local, Network, Physical };

    public enum AvailabilityImpactEnum { High, Low, None };

    public enum SeverityType { Critical, High, Low, Medium, None };

    public enum ModifiedAttackComplexityType { High, Low, NotDefined };

    public enum ModifiedAttackVectorType { AdjacentNetwork, Local, Network, NotDefined, Physical };

    public enum ModifiedType { High, Low, None, NotDefined };

    public enum ModifiedScopeType { Changed, NotDefined, Unchanged };

    public enum ModifiedUserInteractionType { None, NotDefined, Required };

    public enum ConfidenceType { Confirmed, NotDefined, Reasonable, Unknown };

    public enum ScopeType { Changed, Unchanged };

    public enum UserInteractionType { None, Required };

    /// <summary>
    /// CVSS Version
    /// </summary>
    public enum CvssV30_Version { The30 };

    /// <summary>
    /// CVSS Version
    /// </summary>
    public enum CvssV31_Version { The31 };

    /// <summary>
    /// State of CVE - PUBLISHED, REJECTED.
    /// </summary>
    public enum State { Published, Rejected };

    /// <summary>
    /// Indicates the type of information represented in the JSON instance.
    /// </summary>
    public enum DataType { CveRecord };

    /// <summary>
    /// The version of the schema being used. Used to support multiple versions of this format.
    /// </summary>
    public enum DataVersion { The50 };

    public partial class JsonCve
    {
        public static JsonCve FromJson(string json) => JsonConvert.DeserializeObject<JsonCve>(json, CveConverter.Models.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this JsonCve self) => JsonConvert.SerializeObject(self, CveConverter.Models.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                StatusConverter.Singleton,
                TypeEnumConverter.Singleton,
                AccessComplexityTypeConverter.Singleton,
                AccessVectorTypeConverter.Singleton,
                AuthenticationTypeConverter.Singleton,
                CiaTypeConverter.Singleton,
                CiaRequirementTypeConverter.Singleton,
                CollateralDamagePotentialTypeConverter.Singleton,
                ExploitityTypeConverter.Singleton,
                RemediationLevelTypeConverter.Singleton,
                ReportConfidenceTypeConverter.Singleton,
                TargetDistributionTypeConverter.Singleton,
                CvssV20VersionConverter.Singleton,
                AttackComplexityTypeConverter.Singleton,
                AttackVectorTypeConverter.Singleton,
                AvailabilityImpactEnumConverter.Singleton,
                SeverityTypeConverter.Singleton,
                ModifiedAttackComplexityTypeConverter.Singleton,
                ModifiedAttackVectorTypeConverter.Singleton,
                ModifiedTypeConverter.Singleton,
                ModifiedScopeTypeConverter.Singleton,
                ModifiedUserInteractionTypeConverter.Singleton,
                ConfidenceTypeConverter.Singleton,
                ScopeTypeConverter.Singleton,
                UserInteractionTypeConverter.Singleton,
                CvssV30VersionConverter.Singleton,
                CvssV31VersionConverter.Singleton,
                StateConverter.Singleton,
                DataTypeConverter.Singleton,
                DataVersionConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PurpleDecodeArrayConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(List<string>);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            reader.Read();
            var value = new List<string>();
            while (reader.TokenType != JsonToken.EndArray)
            {
                var converter = PurpleMinMaxLengthCheckConverter.Singleton;
                var arrayItem = (string)converter.ReadJson(reader, typeof(string), null, serializer);
                value.Add(arrayItem);
                reader.Read();
            }
            return value;
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (List<string>)untypedValue;
            writer.WriteStartArray();
            foreach (var arrayItem in value)
            {
                var converter = PurpleMinMaxLengthCheckConverter.Singleton;
                converter.WriteJson(writer, arrayItem, serializer);
            }
            writer.WriteEndArray();
            return;
        }

        public static readonly PurpleDecodeArrayConverter Singleton = new PurpleDecodeArrayConverter();
    }

    internal class PurpleMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1 && value.Length <= 2048)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1 && value.Length <= 2048)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly PurpleMinMaxLengthCheckConverter Singleton = new PurpleMinMaxLengthCheckConverter();
    }

    internal class StatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Status) || t == typeof(Status?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "affected":
                    return Status.Affected;
                case "unaffected":
                    return Status.Unaffected;
                case "unknown":
                    return Status.Unknown;
            }
            throw new Exception("Cannot unmarshal type Status");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Status)untypedValue;
            switch (value)
            {
                case Status.Affected:
                    serializer.Serialize(writer, "affected");
                    return;
                case Status.Unaffected:
                    serializer.Serialize(writer, "unaffected");
                    return;
                case Status.Unknown:
                    serializer.Serialize(writer, "unknown");
                    return;
            }
            throw new Exception("Cannot marshal type Status");
        }

        public static readonly StatusConverter Singleton = new StatusConverter();
    }

    internal class FluffyDecodeArrayConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(List<string>);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            reader.Read();
            var value = new List<string>();
            while (reader.TokenType != JsonToken.EndArray)
            {
                var converter = FluffyMinMaxLengthCheckConverter.Singleton;
                var arrayItem = (string)converter.ReadJson(reader, typeof(string), null, serializer);
                value.Add(arrayItem);
                reader.Read();
            }
            return value;
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (List<string>)untypedValue;
            writer.WriteStartArray();
            foreach (var arrayItem in value)
            {
                var converter = FluffyMinMaxLengthCheckConverter.Singleton;
                converter.WriteJson(writer, arrayItem, serializer);
            }
            writer.WriteEndArray();
            return;
        }

        public static readonly FluffyDecodeArrayConverter Singleton = new FluffyDecodeArrayConverter();
    }

    internal class FluffyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1 && value.Length <= 4096)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1 && value.Length <= 4096)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly FluffyMinMaxLengthCheckConverter Singleton = new FluffyMinMaxLengthCheckConverter();
    }

    internal class TentacledMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1 && value.Length <= 2048)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1 && value.Length <= 2048)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly TentacledMinMaxLengthCheckConverter Singleton = new TentacledMinMaxLengthCheckConverter();
    }

    internal class TentacledDecodeArrayConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(List<string>);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            reader.Read();
            var value = new List<string>();
            while (reader.TokenType != JsonToken.EndArray)
            {
                var converter = StickyMinMaxLengthCheckConverter.Singleton;
                var arrayItem = (string)converter.ReadJson(reader, typeof(string), null, serializer);
                value.Add(arrayItem);
                reader.Read();
            }
            return value;
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (List<string>)untypedValue;
            writer.WriteStartArray();
            foreach (var arrayItem in value)
            {
                var converter = StickyMinMaxLengthCheckConverter.Singleton;
                converter.WriteJson(writer, arrayItem, serializer);
            }
            writer.WriteEndArray();
            return;
        }

        public static readonly TentacledDecodeArrayConverter Singleton = new TentacledDecodeArrayConverter();
    }

    internal class StickyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 1024)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 1024)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly StickyMinMaxLengthCheckConverter Singleton = new StickyMinMaxLengthCheckConverter();
    }

    internal class StickyDecodeArrayConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(List<string>);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            reader.Read();
            var value = new List<string>();
            while (reader.TokenType != JsonToken.EndArray)
            {
                var converter = IndigoMinMaxLengthCheckConverter.Singleton;
                var arrayItem = (string)converter.ReadJson(reader, typeof(string), null, serializer);
                value.Add(arrayItem);
                reader.Read();
            }
            return value;
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (List<string>)untypedValue;
            writer.WriteStartArray();
            foreach (var arrayItem in value)
            {
                var converter = IndigoMinMaxLengthCheckConverter.Singleton;
                converter.WriteJson(writer, arrayItem, serializer);
            }
            writer.WriteEndArray();
            return;
        }

        public static readonly StickyDecodeArrayConverter Singleton = new StickyDecodeArrayConverter();
    }

    internal class IndigoMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1 && value.Length <= 1024)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1 && value.Length <= 1024)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly IndigoMinMaxLengthCheckConverter Singleton = new IndigoMinMaxLengthCheckConverter();
    }

    internal class IndecentMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1 && value.Length <= 512)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1 && value.Length <= 512)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly IndecentMinMaxLengthCheckConverter Singleton = new IndecentMinMaxLengthCheckConverter();
    }

    internal class HilariousMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1 && value.Length <= 128)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1 && value.Length <= 128)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly HilariousMinMaxLengthCheckConverter Singleton = new HilariousMinMaxLengthCheckConverter();
    }

    internal class AmbitiousMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1 && value.Length <= 256)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1 && value.Length <= 256)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly AmbitiousMinMaxLengthCheckConverter Singleton = new AmbitiousMinMaxLengthCheckConverter();
    }

    internal class CunningMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1 && value.Length <= 16384)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1 && value.Length <= 16384)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly CunningMinMaxLengthCheckConverter Singleton = new CunningMinMaxLengthCheckConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "analyst":
                    return TypeEnum.Analyst;
                case "coordinator":
                    return TypeEnum.Coordinator;
                case "finder":
                    return TypeEnum.Finder;
                case "other":
                    return TypeEnum.Other;
                case "remediation developer":
                    return TypeEnum.RemediationDeveloper;
                case "remediation reviewer":
                    return TypeEnum.RemediationReviewer;
                case "remediation verifier":
                    return TypeEnum.RemediationVerifier;
                case "reporter":
                    return TypeEnum.Reporter;
                case "sponsor":
                    return TypeEnum.Sponsor;
                case "tool":
                    return TypeEnum.Tool;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.Analyst:
                    serializer.Serialize(writer, "analyst");
                    return;
                case TypeEnum.Coordinator:
                    serializer.Serialize(writer, "coordinator");
                    return;
                case TypeEnum.Finder:
                    serializer.Serialize(writer, "finder");
                    return;
                case TypeEnum.Other:
                    serializer.Serialize(writer, "other");
                    return;
                case TypeEnum.RemediationDeveloper:
                    serializer.Serialize(writer, "remediation developer");
                    return;
                case TypeEnum.RemediationReviewer:
                    serializer.Serialize(writer, "remediation reviewer");
                    return;
                case TypeEnum.RemediationVerifier:
                    serializer.Serialize(writer, "remediation verifier");
                    return;
                case TypeEnum.Reporter:
                    serializer.Serialize(writer, "reporter");
                    return;
                case TypeEnum.Sponsor:
                    serializer.Serialize(writer, "sponsor");
                    return;
                case TypeEnum.Tool:
                    serializer.Serialize(writer, "tool");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }

    internal class MagentaMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 7 && value.Length <= 11)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 7 && value.Length <= 11)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly MagentaMinMaxLengthCheckConverter Singleton = new MagentaMinMaxLengthCheckConverter();
    }

    internal class AccessComplexityTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AccessComplexityType) || t == typeof(AccessComplexityType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "HIGH":
                    return AccessComplexityType.High;
                case "LOW":
                    return AccessComplexityType.Low;
                case "MEDIUM":
                    return AccessComplexityType.Medium;
            }
            throw new Exception("Cannot unmarshal type AccessComplexityType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AccessComplexityType)untypedValue;
            switch (value)
            {
                case AccessComplexityType.High:
                    serializer.Serialize(writer, "HIGH");
                    return;
                case AccessComplexityType.Low:
                    serializer.Serialize(writer, "LOW");
                    return;
                case AccessComplexityType.Medium:
                    serializer.Serialize(writer, "MEDIUM");
                    return;
            }
            throw new Exception("Cannot marshal type AccessComplexityType");
        }

        public static readonly AccessComplexityTypeConverter Singleton = new AccessComplexityTypeConverter();
    }

    internal class AccessVectorTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AccessVectorType) || t == typeof(AccessVectorType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ADJACENT_NETWORK":
                    return AccessVectorType.AdjacentNetwork;
                case "LOCAL":
                    return AccessVectorType.Local;
                case "NETWORK":
                    return AccessVectorType.Network;
            }
            throw new Exception("Cannot unmarshal type AccessVectorType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AccessVectorType)untypedValue;
            switch (value)
            {
                case AccessVectorType.AdjacentNetwork:
                    serializer.Serialize(writer, "ADJACENT_NETWORK");
                    return;
                case AccessVectorType.Local:
                    serializer.Serialize(writer, "LOCAL");
                    return;
                case AccessVectorType.Network:
                    serializer.Serialize(writer, "NETWORK");
                    return;
            }
            throw new Exception("Cannot marshal type AccessVectorType");
        }

        public static readonly AccessVectorTypeConverter Singleton = new AccessVectorTypeConverter();
    }

    internal class AuthenticationTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AuthenticationType) || t == typeof(AuthenticationType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "MULTIPLE":
                    return AuthenticationType.Multiple;
                case "NONE":
                    return AuthenticationType.None;
                case "SINGLE":
                    return AuthenticationType.Single;
            }
            throw new Exception("Cannot unmarshal type AuthenticationType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AuthenticationType)untypedValue;
            switch (value)
            {
                case AuthenticationType.Multiple:
                    serializer.Serialize(writer, "MULTIPLE");
                    return;
                case AuthenticationType.None:
                    serializer.Serialize(writer, "NONE");
                    return;
                case AuthenticationType.Single:
                    serializer.Serialize(writer, "SINGLE");
                    return;
            }
            throw new Exception("Cannot marshal type AuthenticationType");
        }

        public static readonly AuthenticationTypeConverter Singleton = new AuthenticationTypeConverter();
    }

    internal class CiaTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CiaType) || t == typeof(CiaType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "COMPLETE":
                    return CiaType.Complete;
                case "NONE":
                    return CiaType.None;
                case "PARTIAL":
                    return CiaType.Partial;
            }
            throw new Exception("Cannot unmarshal type CiaType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CiaType)untypedValue;
            switch (value)
            {
                case CiaType.Complete:
                    serializer.Serialize(writer, "COMPLETE");
                    return;
                case CiaType.None:
                    serializer.Serialize(writer, "NONE");
                    return;
                case CiaType.Partial:
                    serializer.Serialize(writer, "PARTIAL");
                    return;
            }
            throw new Exception("Cannot marshal type CiaType");
        }

        public static readonly CiaTypeConverter Singleton = new CiaTypeConverter();
    }

    internal class CiaRequirementTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CiaRequirementType) || t == typeof(CiaRequirementType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "HIGH":
                    return CiaRequirementType.High;
                case "LOW":
                    return CiaRequirementType.Low;
                case "MEDIUM":
                    return CiaRequirementType.Medium;
                case "NOT_DEFINED":
                    return CiaRequirementType.NotDefined;
            }
            throw new Exception("Cannot unmarshal type CiaRequirementType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CiaRequirementType)untypedValue;
            switch (value)
            {
                case CiaRequirementType.High:
                    serializer.Serialize(writer, "HIGH");
                    return;
                case CiaRequirementType.Low:
                    serializer.Serialize(writer, "LOW");
                    return;
                case CiaRequirementType.Medium:
                    serializer.Serialize(writer, "MEDIUM");
                    return;
                case CiaRequirementType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
            }
            throw new Exception("Cannot marshal type CiaRequirementType");
        }

        public static readonly CiaRequirementTypeConverter Singleton = new CiaRequirementTypeConverter();
    }

    internal class MinMaxValueCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(double) || t == typeof(double?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<double>(reader);
            if (value >= 0 && value <= 10)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type double");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (double)untypedValue;
            if (value >= 0 && value <= 10)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type double");
        }

        public static readonly MinMaxValueCheckConverter Singleton = new MinMaxValueCheckConverter();
    }

    internal class CollateralDamagePotentialTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CollateralDamagePotentialType) || t == typeof(CollateralDamagePotentialType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "HIGH":
                    return CollateralDamagePotentialType.High;
                case "LOW":
                    return CollateralDamagePotentialType.Low;
                case "LOW_MEDIUM":
                    return CollateralDamagePotentialType.LowMedium;
                case "MEDIUM_HIGH":
                    return CollateralDamagePotentialType.MediumHigh;
                case "NONE":
                    return CollateralDamagePotentialType.None;
                case "NOT_DEFINED":
                    return CollateralDamagePotentialType.NotDefined;
            }
            throw new Exception("Cannot unmarshal type CollateralDamagePotentialType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CollateralDamagePotentialType)untypedValue;
            switch (value)
            {
                case CollateralDamagePotentialType.High:
                    serializer.Serialize(writer, "HIGH");
                    return;
                case CollateralDamagePotentialType.Low:
                    serializer.Serialize(writer, "LOW");
                    return;
                case CollateralDamagePotentialType.LowMedium:
                    serializer.Serialize(writer, "LOW_MEDIUM");
                    return;
                case CollateralDamagePotentialType.MediumHigh:
                    serializer.Serialize(writer, "MEDIUM_HIGH");
                    return;
                case CollateralDamagePotentialType.None:
                    serializer.Serialize(writer, "NONE");
                    return;
                case CollateralDamagePotentialType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
            }
            throw new Exception("Cannot marshal type CollateralDamagePotentialType");
        }

        public static readonly CollateralDamagePotentialTypeConverter Singleton = new CollateralDamagePotentialTypeConverter();
    }

    internal class ExploitityTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ExploitityType) || t == typeof(ExploitityType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "FUNCTIONAL":
                    return ExploitityType.Functional;
                case "HIGH":
                    return ExploitityType.High;
                case "NOT_DEFINED":
                    return ExploitityType.NotDefined;
                case "PROOF_OF_CONCEPT":
                    return ExploitityType.ProofOfConcept;
                case "UNPROVEN":
                    return ExploitityType.Unproven;
            }
            throw new Exception("Cannot unmarshal type ExploitityType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ExploitityType)untypedValue;
            switch (value)
            {
                case ExploitityType.Functional:
                    serializer.Serialize(writer, "FUNCTIONAL");
                    return;
                case ExploitityType.High:
                    serializer.Serialize(writer, "HIGH");
                    return;
                case ExploitityType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
                case ExploitityType.ProofOfConcept:
                    serializer.Serialize(writer, "PROOF_OF_CONCEPT");
                    return;
                case ExploitityType.Unproven:
                    serializer.Serialize(writer, "UNPROVEN");
                    return;
            }
            throw new Exception("Cannot marshal type ExploitityType");
        }

        public static readonly ExploitityTypeConverter Singleton = new ExploitityTypeConverter();
    }

    internal class RemediationLevelTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RemediationLevelType) || t == typeof(RemediationLevelType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "NOT_DEFINED":
                    return RemediationLevelType.NotDefined;
                case "OFFICIAL_FIX":
                    return RemediationLevelType.OfficialFix;
                case "TEMPORARY_FIX":
                    return RemediationLevelType.TemporaryFix;
                case "UNAVAILABLE":
                    return RemediationLevelType.Unavailable;
                case "WORKAROUND":
                    return RemediationLevelType.Workaround;
            }
            throw new Exception("Cannot unmarshal type RemediationLevelType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (RemediationLevelType)untypedValue;
            switch (value)
            {
                case RemediationLevelType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
                case RemediationLevelType.OfficialFix:
                    serializer.Serialize(writer, "OFFICIAL_FIX");
                    return;
                case RemediationLevelType.TemporaryFix:
                    serializer.Serialize(writer, "TEMPORARY_FIX");
                    return;
                case RemediationLevelType.Unavailable:
                    serializer.Serialize(writer, "UNAVAILABLE");
                    return;
                case RemediationLevelType.Workaround:
                    serializer.Serialize(writer, "WORKAROUND");
                    return;
            }
            throw new Exception("Cannot marshal type RemediationLevelType");
        }

        public static readonly RemediationLevelTypeConverter Singleton = new RemediationLevelTypeConverter();
    }

    internal class ReportConfidenceTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ReportConfidenceType) || t == typeof(ReportConfidenceType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CONFIRMED":
                    return ReportConfidenceType.Confirmed;
                case "NOT_DEFINED":
                    return ReportConfidenceType.NotDefined;
                case "UNCONFIRMED":
                    return ReportConfidenceType.Unconfirmed;
                case "UNCORROBORATED":
                    return ReportConfidenceType.Uncorroborated;
            }
            throw new Exception("Cannot unmarshal type ReportConfidenceType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ReportConfidenceType)untypedValue;
            switch (value)
            {
                case ReportConfidenceType.Confirmed:
                    serializer.Serialize(writer, "CONFIRMED");
                    return;
                case ReportConfidenceType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
                case ReportConfidenceType.Unconfirmed:
                    serializer.Serialize(writer, "UNCONFIRMED");
                    return;
                case ReportConfidenceType.Uncorroborated:
                    serializer.Serialize(writer, "UNCORROBORATED");
                    return;
            }
            throw new Exception("Cannot marshal type ReportConfidenceType");
        }

        public static readonly ReportConfidenceTypeConverter Singleton = new ReportConfidenceTypeConverter();
    }

    internal class TargetDistributionTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TargetDistributionType) || t == typeof(TargetDistributionType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "HIGH":
                    return TargetDistributionType.High;
                case "LOW":
                    return TargetDistributionType.Low;
                case "MEDIUM":
                    return TargetDistributionType.Medium;
                case "NONE":
                    return TargetDistributionType.None;
                case "NOT_DEFINED":
                    return TargetDistributionType.NotDefined;
            }
            throw new Exception("Cannot unmarshal type TargetDistributionType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TargetDistributionType)untypedValue;
            switch (value)
            {
                case TargetDistributionType.High:
                    serializer.Serialize(writer, "HIGH");
                    return;
                case TargetDistributionType.Low:
                    serializer.Serialize(writer, "LOW");
                    return;
                case TargetDistributionType.Medium:
                    serializer.Serialize(writer, "MEDIUM");
                    return;
                case TargetDistributionType.None:
                    serializer.Serialize(writer, "NONE");
                    return;
                case TargetDistributionType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
            }
            throw new Exception("Cannot marshal type TargetDistributionType");
        }

        public static readonly TargetDistributionTypeConverter Singleton = new TargetDistributionTypeConverter();
    }

    internal class CvssV20VersionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CvssV20_Version) || t == typeof(CvssV20_Version?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "2.0")
            {
                return CvssV20_Version.The20;
            }
            throw new Exception("Cannot unmarshal type CvssV20_Version");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CvssV20_Version)untypedValue;
            if (value == CvssV20_Version.The20)
            {
                serializer.Serialize(writer, "2.0");
                return;
            }
            throw new Exception("Cannot marshal type CvssV20_Version");
        }

        public static readonly CvssV20VersionConverter Singleton = new CvssV20VersionConverter();
    }

    internal class AttackComplexityTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AttackComplexityType) || t == typeof(AttackComplexityType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "HIGH":
                    return AttackComplexityType.High;
                case "LOW":
                    return AttackComplexityType.Low;
            }
            throw new Exception("Cannot unmarshal type AttackComplexityType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AttackComplexityType)untypedValue;
            switch (value)
            {
                case AttackComplexityType.High:
                    serializer.Serialize(writer, "HIGH");
                    return;
                case AttackComplexityType.Low:
                    serializer.Serialize(writer, "LOW");
                    return;
            }
            throw new Exception("Cannot marshal type AttackComplexityType");
        }

        public static readonly AttackComplexityTypeConverter Singleton = new AttackComplexityTypeConverter();
    }

    internal class AttackVectorTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AttackVectorType) || t == typeof(AttackVectorType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ADJACENT_NETWORK":
                    return AttackVectorType.AdjacentNetwork;
                case "LOCAL":
                    return AttackVectorType.Local;
                case "NETWORK":
                    return AttackVectorType.Network;
                case "PHYSICAL":
                    return AttackVectorType.Physical;
            }
            throw new Exception("Cannot unmarshal type AttackVectorType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AttackVectorType)untypedValue;
            switch (value)
            {
                case AttackVectorType.AdjacentNetwork:
                    serializer.Serialize(writer, "ADJACENT_NETWORK");
                    return;
                case AttackVectorType.Local:
                    serializer.Serialize(writer, "LOCAL");
                    return;
                case AttackVectorType.Network:
                    serializer.Serialize(writer, "NETWORK");
                    return;
                case AttackVectorType.Physical:
                    serializer.Serialize(writer, "PHYSICAL");
                    return;
            }
            throw new Exception("Cannot marshal type AttackVectorType");
        }

        public static readonly AttackVectorTypeConverter Singleton = new AttackVectorTypeConverter();
    }

    internal class AvailabilityImpactEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AvailabilityImpactEnum) || t == typeof(AvailabilityImpactEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "HIGH":
                    return AvailabilityImpactEnum.High;
                case "LOW":
                    return AvailabilityImpactEnum.Low;
                case "NONE":
                    return AvailabilityImpactEnum.None;
            }
            throw new Exception("Cannot unmarshal type AvailabilityImpactEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AvailabilityImpactEnum)untypedValue;
            switch (value)
            {
                case AvailabilityImpactEnum.High:
                    serializer.Serialize(writer, "HIGH");
                    return;
                case AvailabilityImpactEnum.Low:
                    serializer.Serialize(writer, "LOW");
                    return;
                case AvailabilityImpactEnum.None:
                    serializer.Serialize(writer, "NONE");
                    return;
            }
            throw new Exception("Cannot marshal type AvailabilityImpactEnum");
        }

        public static readonly AvailabilityImpactEnumConverter Singleton = new AvailabilityImpactEnumConverter();
    }

    internal class SeverityTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SeverityType) || t == typeof(SeverityType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CRITICAL":
                    return SeverityType.Critical;
                case "HIGH":
                    return SeverityType.High;
                case "LOW":
                    return SeverityType.Low;
                case "MEDIUM":
                    return SeverityType.Medium;
                case "NONE":
                    return SeverityType.None;
            }
            throw new Exception("Cannot unmarshal type SeverityType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SeverityType)untypedValue;
            switch (value)
            {
                case SeverityType.Critical:
                    serializer.Serialize(writer, "CRITICAL");
                    return;
                case SeverityType.High:
                    serializer.Serialize(writer, "HIGH");
                    return;
                case SeverityType.Low:
                    serializer.Serialize(writer, "LOW");
                    return;
                case SeverityType.Medium:
                    serializer.Serialize(writer, "MEDIUM");
                    return;
                case SeverityType.None:
                    serializer.Serialize(writer, "NONE");
                    return;
            }
            throw new Exception("Cannot marshal type SeverityType");
        }

        public static readonly SeverityTypeConverter Singleton = new SeverityTypeConverter();
    }

    internal class ModifiedAttackComplexityTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ModifiedAttackComplexityType) || t == typeof(ModifiedAttackComplexityType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "HIGH":
                    return ModifiedAttackComplexityType.High;
                case "LOW":
                    return ModifiedAttackComplexityType.Low;
                case "NOT_DEFINED":
                    return ModifiedAttackComplexityType.NotDefined;
            }
            throw new Exception("Cannot unmarshal type ModifiedAttackComplexityType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ModifiedAttackComplexityType)untypedValue;
            switch (value)
            {
                case ModifiedAttackComplexityType.High:
                    serializer.Serialize(writer, "HIGH");
                    return;
                case ModifiedAttackComplexityType.Low:
                    serializer.Serialize(writer, "LOW");
                    return;
                case ModifiedAttackComplexityType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
            }
            throw new Exception("Cannot marshal type ModifiedAttackComplexityType");
        }

        public static readonly ModifiedAttackComplexityTypeConverter Singleton = new ModifiedAttackComplexityTypeConverter();
    }

    internal class ModifiedAttackVectorTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ModifiedAttackVectorType) || t == typeof(ModifiedAttackVectorType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ADJACENT_NETWORK":
                    return ModifiedAttackVectorType.AdjacentNetwork;
                case "LOCAL":
                    return ModifiedAttackVectorType.Local;
                case "NETWORK":
                    return ModifiedAttackVectorType.Network;
                case "NOT_DEFINED":
                    return ModifiedAttackVectorType.NotDefined;
                case "PHYSICAL":
                    return ModifiedAttackVectorType.Physical;
            }
            throw new Exception("Cannot unmarshal type ModifiedAttackVectorType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ModifiedAttackVectorType)untypedValue;
            switch (value)
            {
                case ModifiedAttackVectorType.AdjacentNetwork:
                    serializer.Serialize(writer, "ADJACENT_NETWORK");
                    return;
                case ModifiedAttackVectorType.Local:
                    serializer.Serialize(writer, "LOCAL");
                    return;
                case ModifiedAttackVectorType.Network:
                    serializer.Serialize(writer, "NETWORK");
                    return;
                case ModifiedAttackVectorType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
                case ModifiedAttackVectorType.Physical:
                    serializer.Serialize(writer, "PHYSICAL");
                    return;
            }
            throw new Exception("Cannot marshal type ModifiedAttackVectorType");
        }

        public static readonly ModifiedAttackVectorTypeConverter Singleton = new ModifiedAttackVectorTypeConverter();
    }

    internal class ModifiedTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ModifiedType) || t == typeof(ModifiedType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "HIGH":
                    return ModifiedType.High;
                case "LOW":
                    return ModifiedType.Low;
                case "NONE":
                    return ModifiedType.None;
                case "NOT_DEFINED":
                    return ModifiedType.NotDefined;
            }
            throw new Exception("Cannot unmarshal type ModifiedType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ModifiedType)untypedValue;
            switch (value)
            {
                case ModifiedType.High:
                    serializer.Serialize(writer, "HIGH");
                    return;
                case ModifiedType.Low:
                    serializer.Serialize(writer, "LOW");
                    return;
                case ModifiedType.None:
                    serializer.Serialize(writer, "NONE");
                    return;
                case ModifiedType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
            }
            throw new Exception("Cannot marshal type ModifiedType");
        }

        public static readonly ModifiedTypeConverter Singleton = new ModifiedTypeConverter();
    }

    internal class ModifiedScopeTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ModifiedScopeType) || t == typeof(ModifiedScopeType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CHANGED":
                    return ModifiedScopeType.Changed;
                case "NOT_DEFINED":
                    return ModifiedScopeType.NotDefined;
                case "UNCHANGED":
                    return ModifiedScopeType.Unchanged;
            }
            throw new Exception("Cannot unmarshal type ModifiedScopeType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ModifiedScopeType)untypedValue;
            switch (value)
            {
                case ModifiedScopeType.Changed:
                    serializer.Serialize(writer, "CHANGED");
                    return;
                case ModifiedScopeType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
                case ModifiedScopeType.Unchanged:
                    serializer.Serialize(writer, "UNCHANGED");
                    return;
            }
            throw new Exception("Cannot marshal type ModifiedScopeType");
        }

        public static readonly ModifiedScopeTypeConverter Singleton = new ModifiedScopeTypeConverter();
    }

    internal class ModifiedUserInteractionTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ModifiedUserInteractionType) || t == typeof(ModifiedUserInteractionType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "NONE":
                    return ModifiedUserInteractionType.None;
                case "NOT_DEFINED":
                    return ModifiedUserInteractionType.NotDefined;
                case "REQUIRED":
                    return ModifiedUserInteractionType.Required;
            }
            throw new Exception("Cannot unmarshal type ModifiedUserInteractionType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ModifiedUserInteractionType)untypedValue;
            switch (value)
            {
                case ModifiedUserInteractionType.None:
                    serializer.Serialize(writer, "NONE");
                    return;
                case ModifiedUserInteractionType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
                case ModifiedUserInteractionType.Required:
                    serializer.Serialize(writer, "REQUIRED");
                    return;
            }
            throw new Exception("Cannot marshal type ModifiedUserInteractionType");
        }

        public static readonly ModifiedUserInteractionTypeConverter Singleton = new ModifiedUserInteractionTypeConverter();
    }

    internal class ConfidenceTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ConfidenceType) || t == typeof(ConfidenceType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CONFIRMED":
                    return ConfidenceType.Confirmed;
                case "NOT_DEFINED":
                    return ConfidenceType.NotDefined;
                case "REASONABLE":
                    return ConfidenceType.Reasonable;
                case "UNKNOWN":
                    return ConfidenceType.Unknown;
            }
            throw new Exception("Cannot unmarshal type ConfidenceType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ConfidenceType)untypedValue;
            switch (value)
            {
                case ConfidenceType.Confirmed:
                    serializer.Serialize(writer, "CONFIRMED");
                    return;
                case ConfidenceType.NotDefined:
                    serializer.Serialize(writer, "NOT_DEFINED");
                    return;
                case ConfidenceType.Reasonable:
                    serializer.Serialize(writer, "REASONABLE");
                    return;
                case ConfidenceType.Unknown:
                    serializer.Serialize(writer, "UNKNOWN");
                    return;
            }
            throw new Exception("Cannot marshal type ConfidenceType");
        }

        public static readonly ConfidenceTypeConverter Singleton = new ConfidenceTypeConverter();
    }

    internal class ScopeTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScopeType) || t == typeof(ScopeType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CHANGED":
                    return ScopeType.Changed;
                case "UNCHANGED":
                    return ScopeType.Unchanged;
            }
            throw new Exception("Cannot unmarshal type ScopeType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ScopeType)untypedValue;
            switch (value)
            {
                case ScopeType.Changed:
                    serializer.Serialize(writer, "CHANGED");
                    return;
                case ScopeType.Unchanged:
                    serializer.Serialize(writer, "UNCHANGED");
                    return;
            }
            throw new Exception("Cannot marshal type ScopeType");
        }

        public static readonly ScopeTypeConverter Singleton = new ScopeTypeConverter();
    }

    internal class UserInteractionTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UserInteractionType) || t == typeof(UserInteractionType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "NONE":
                    return UserInteractionType.None;
                case "REQUIRED":
                    return UserInteractionType.Required;
            }
            throw new Exception("Cannot unmarshal type UserInteractionType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (UserInteractionType)untypedValue;
            switch (value)
            {
                case UserInteractionType.None:
                    serializer.Serialize(writer, "NONE");
                    return;
                case UserInteractionType.Required:
                    serializer.Serialize(writer, "REQUIRED");
                    return;
            }
            throw new Exception("Cannot marshal type UserInteractionType");
        }

        public static readonly UserInteractionTypeConverter Singleton = new UserInteractionTypeConverter();
    }

    internal class CvssV30VersionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CvssV30_Version) || t == typeof(CvssV30_Version?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "3.0")
            {
                return CvssV30_Version.The30;
            }
            throw new Exception("Cannot unmarshal type CvssV30_Version");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CvssV30_Version)untypedValue;
            if (value == CvssV30_Version.The30)
            {
                serializer.Serialize(writer, "3.0");
                return;
            }
            throw new Exception("Cannot marshal type CvssV30_Version");
        }

        public static readonly CvssV30VersionConverter Singleton = new CvssV30VersionConverter();
    }

    internal class CvssV31VersionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CvssV31_Version) || t == typeof(CvssV31_Version?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "3.1")
            {
                return CvssV31_Version.The31;
            }
            throw new Exception("Cannot unmarshal type CvssV31_Version");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CvssV31_Version)untypedValue;
            if (value == CvssV31_Version.The31)
            {
                serializer.Serialize(writer, "3.1");
                return;
            }
            throw new Exception("Cannot marshal type CvssV31_Version");
        }

        public static readonly CvssV31VersionConverter Singleton = new CvssV31VersionConverter();
    }

    internal class FriskyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1 && value.Length <= 64)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1 && value.Length <= 64)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly FriskyMinMaxLengthCheckConverter Singleton = new FriskyMinMaxLengthCheckConverter();
    }

    internal class MischievousMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 5 && value.Length <= 9)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 5 && value.Length <= 9)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly MischievousMinMaxLengthCheckConverter Singleton = new MischievousMinMaxLengthCheckConverter();
    }

    internal class IndigoDecodeArrayConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(List<string>);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            reader.Read();
            var value = new List<string>();
            while (reader.TokenType != JsonToken.EndArray)
            {
                var converter = BraggadociousMinMaxLengthCheckConverter.Singleton;
                var arrayItem = (string)converter.ReadJson(reader, typeof(string), null, serializer);
                value.Add(arrayItem);
                reader.Read();
            }
            return value;
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (List<string>)untypedValue;
            writer.WriteStartArray();
            foreach (var arrayItem in value)
            {
                var converter = BraggadociousMinMaxLengthCheckConverter.Singleton;
                converter.WriteJson(writer, arrayItem, serializer);
            }
            writer.WriteEndArray();
            return;
        }

        public static readonly IndigoDecodeArrayConverter Singleton = new IndigoDecodeArrayConverter();
    }

    internal class BraggadociousMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 2 && value.Length <= 128)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 2 && value.Length <= 128)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly BraggadociousMinMaxLengthCheckConverter Singleton = new BraggadociousMinMaxLengthCheckConverter();
    }

    internal class MinMaxLengthCheckConverter1 : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 2 && value.Length <= 32)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 2 && value.Length <= 32)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly MinMaxLengthCheckConverter1 Singleton = new MinMaxLengthCheckConverter1();
    }

    internal class StateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(State) || t == typeof(State?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "PUBLISHED":
                    return State.Published;
                case "REJECTED":
                    return State.Rejected;
            }
            throw new Exception("Cannot unmarshal type State");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (State)untypedValue;
            switch (value)
            {
                case State.Published:
                    serializer.Serialize(writer, "PUBLISHED");
                    return;
                case State.Rejected:
                    serializer.Serialize(writer, "REJECTED");
                    return;
            }
            throw new Exception("Cannot marshal type State");
        }

        public static readonly StateConverter Singleton = new StateConverter();
    }

    internal class DataTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DataType) || t == typeof(DataType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "CVE_RECORD")
            {
                return DataType.CveRecord;
            }
            throw new Exception("Cannot unmarshal type DataType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DataType)untypedValue;
            if (value == DataType.CveRecord)
            {
                serializer.Serialize(writer, "CVE_RECORD");
                return;
            }
            throw new Exception("Cannot marshal type DataType");
        }

        public static readonly DataTypeConverter Singleton = new DataTypeConverter();
    }

    internal class DataVersionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DataVersion) || t == typeof(DataVersion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "5.0")
            {
                return DataVersion.The50;
            }
            throw new Exception("Cannot unmarshal type DataVersion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DataVersion)untypedValue;
            if (value == DataVersion.The50)
            {
                serializer.Serialize(writer, "5.0");
                return;
            }
            throw new Exception("Cannot marshal type DataVersion");
        }

        public static readonly DataVersionConverter Singleton = new DataVersionConverter();
    }
}
